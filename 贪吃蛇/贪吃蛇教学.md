# 🐍 贪吃蛇游戏项目

## 一、定位

- **项目目标**:
  - 理解“网格坐标”“主循环”“事件处理”“状态更新”的基本概念
  - 能独立运行并修改一个简易贪吃蛇游戏（玩家模式）
  - 知道如何让蛇吃食物变长、计分、检测死亡
  - 了解简单 AI 的思路（选学）：让蛇更“聪明”地找食物
- **项目产出**:
  - 本地可运行的`Snake Game`
  - 了解项目运行的基础逻辑和模块作用

---

## 二、运行环境与快速上手

1. 安装 Python 3.10+。
2. 安装依赖：

   - 打开终端进入项目目录：`python-course/贪吃蛇`
   - 安装 pygame：
     ```bash
     pip install pygame
     ```
3. 运行游戏：

   ```bash
   python snake_game.py
   ```

   - 弹窗会询问是否启用 AI 模式（Yes=AI，No=Player），建议先选“否”，体验玩家模式。
   - 可设置胜利分数（默认 10）。

若运行报错：

- `ModuleNotFoundError: No module named 'pygame'` → 重新执行 `pip install pygame`
- 字体/弹窗异常 → 直接回车进入默认设置即可；或改`snake_game.py`内的交互为固定值（进阶）。

---

## 先想一想这个游戏需要哪些“结构”

- 我们要做的“世界”里有哪些角色？需要记住哪些信息？
- 每一帧，谁会改变？是谁来决定怎么改变（玩家/AI/规则）？
- 什么时候算胜利？什么时候算失败？
- **把游戏拆成 信息-规则-动作**

  - 信息（状态）：
    - 蛇：身体坐标列表、前进方向
    - 食物：位置
    - 分数与胜利目标：当前分数、目标分数
    - 地图：宽高、网格大小、颜色
  - 规则（判断）：
    - 蛇每帧前进一格；不能原地掉头
    - 头部与食物重合→加分、长一节、刷新食物
    - 撞墙/撞到自己→失败；分数达标→胜利
  - 动作（行为）：
    - 玩家按键或 AI 选择方向
    - 更新一次“帧”：移动→判定→计分/结束→渲染
    - 重新开始或退出
- **角色/对象雏形**

  - 蛇（Snake）：
    - 属性：`body`（一串坐标）、`direction`
    - 行为：`set_direction`、`move`、`grow`、`hit_wall`、`hit_self`
  - 食物（Food）：
    - 属性：`position`
    - 行为：`random_position`、`respawn`
  - 游戏/世界（Game）：
    - 属性：窗口、分数、目标分数、模式（玩家/AI）
    - 行为：处理事件、让 AI 决策、更新一帧、画网格/蛇/食物、结束与重开
- **与代码映射**

  - 蛇 → `snake.py`
  - 食物 → `food.py`
  - 世界/循环/渲染/计分/结束 → `game.py`
  - 参数配置 → `config.py`
  - AI 决策 → `snake_ai.py`
  - 入口与启动配置 → `snake_game.py`

---

## 三、项目结构一览

- `config.py`：集中管理参数（窗口大小、颜色、网格尺寸、默认胜利分数）。
- `snake.py`：定义蛇（身体列表、方向、移动、长身体、碰撞自检）。
- `food.py`：食物（随机生成且不与蛇重叠、刷新）。
- `snake_ai.py`：两种 AI（简单直线靠近、BFS 更安全）。
- `game.py`：游戏主逻辑（事件→更新→渲染），计分、结束/胜利弹窗。
- `snake_game.py`：程序入口（选择模式、设置分数）。

---

## 四、核心概念

- **网格与坐标**：屏幕按`GRID_SIZE`切成小格。蛇和食物都在格子中移动；位置用`(x, y)`表示。
- **状态与更新**：游戏每一帧都做三件事：读事件→更新状态（蛇移动、吃食物、加分、死亡判断）→画出来。
- **事件处理**：玩家通过方向键控制；AI 模式则由程序自动给方向。
- **避免反向**：不能从右直接转到左（会“折返”撞到自己）。

---

## 五、从零到完整：实现路线（一步步）

以下步骤与现有代码对应，老师可“讲→改一行/加一段→运行观察”，保证“每步可见变化”。每一步包含：文件与位置 → 具体操作 → 你应看到 → 常见问题。

### 步骤1：创建窗口与网格（看得见的世界）

- 实现思路：
  - 用固定大小的窗口作为“世界”，将像素按`GRID_SIZE`划分为网格（把连续空间离散化）。
  - 每一帧的渲染遵循：清屏→画网格→画实体（蛇/食物）→画UI（分数），让学生“看见数据”。
  - 网格只是视觉辅助，不改变游戏规则；`GRID_SIZE`越小，运动越“细腻”，越大越“像素风”。
- 文件与位置：
  - `config.py`：`WIDTH/HEIGHT/GRID_SIZE`
  - `game.py`：`Game.__init__`、`draw_grid`、`draw_block`
- 具体操作：
  1) 运行`snake_game.py`确认窗口能打开。
  2) 修改`config.py`中的`GRID_SIZE`为`40`或`10`，保存后再次运行。
  3) 在`config.py`把`BG_COLOR`改为更亮/更暗，观察背景变化。
- 你应看到：
  - 网格线随`GRID_SIZE`变化而变稀/变密；背景颜色改变。
- 扩展：
  - 增加“显示网格”开关（在`config.py`加入`SHOW_GRID`，`draw()`按需调用`draw_grid`）。
  - 支持主题切换：定义主题字典（配色方案），用按键或启动参数在主题间切换。
  - 让`GRID_SIZE`随窗口大小自适应，或从配置文件/命令行读取参数。

### 步骤2：表示一条蛇（数据结构）

- 实现思路：
  - 用“有序的格子坐标列表”表示蛇身体，列表头部是蛇头，后续是身体与尾巴。
  - 方向是一个简单的向量（如`(1,0)`向右），与坐标相加得到下一帧的位置。
  - 初始长度与朝向只是“状态初始化”，便于让学生理解“数据决定画面”。
- 文件与位置：
  - `snake.py`：`class Snake` 的 `body`、方向常量`UP/DOWN/LEFT/RIGHT`
  - `game.py.draw`：蛇头黄色、身体绿色
- 具体操作：
  1) 打开`snake.py`，阅读初始`body = [(5,5),(4,5),(3,5)]`。
  2) 把初始身体改短或加长（如 2 节/5 节），保存并运行观察。
  3) 把蛇的初始方向`self.direction`改为`UP/LEFT`等，运行观察蛇起步方向。
- 你应看到：
  - 初始时蛇在屏幕上有不同长度、不同朝向。
- 扩展：
  - 用`collections.deque`存储`body`以便高效头插尾弹（认识数据结构取舍）。
  - 抽象方向为`Enum`，统一玩家输入与AI的方向接口。
  - 增加`reset(start_len, start_dir)`方法，便于重开或难度切换。

### 步骤3：移动与方向控制

- 实现思路：
  - “移动”=在头部插入一个新坐标；若不长身体则弹出尾巴，保持总长度不变。
  - 方向由玩家事件或AI策略决定，但都统一成“把方向向量加到蛇头坐标”。
  - 为防“直接掉头”，限制新方向与旧方向相加不为`(0,0)`（抽象为“不能反向”规则）。
- 文件与位置：
  - `snake.py`：`set_direction()`（防反向）、`move()`（插头/弹尾）
  - `game.py`：`handle_events()`方向键映射、`clock.tick(10)`节奏
- 具体操作：
  1) 运行玩家模式，按`↑↓←→`观察蛇移动。
  2) 在`game.py`中把`clock.tick(10)`改为`15/5`，感受速度变化。
  3) 可选：在`handle_events()`里为`WASD`添加同样的方向映射。
- 你应看到：
  - 蛇头每帧前进一步；速度随`tick`值变化；无法“直接掉头”。
- 扩展：
  - 增加暂停/继续与单步前进（便于课堂演示与调试）。
  - 支持“穿墙模式”（从左出右进）作为可选规则，体验不同关卡风格。
  - 设置最小转向间隔帧，减少误操作导致的自撞。

### 步骤4：食物与长身体

- 实现思路：
  - 食物的位置是“随机可用格子”中的一个，需要避开蛇身体（约束随机）。
  - 吃到食物的判定是“蛇头与食物位置重合”。吃到后本帧不弹尾巴，等价于“长度+1”。
  - 加分与刷新食物是“状态变化”的一部分，保持规则简单且一致。
- 文件与位置：
  - `food.py`：`random_position()`、`respawn()`
  - `snake.py`：`grow()`、`grow_flag`
  - `game.py.update()`：吃到判定、加分与刷新
- 具体操作：
  1) 运行后尝试“吃到食物”，观察蛇是否增长、分数是否+1。
  2) 在`food.py`的`random_position`中临时打印`pos`（调试），理解“随机直到不重叠”。
  3) 可选：把食物颜色在`game.py.draw()`里改成别的颜色。
- 你应看到：
  - 吃到食物后，当前帧尾巴不弹出（长度+1），分数增加，食物刷新到新位置。
- 扩展：
  - 同屏多食物与“特殊食物”（限时、加倍、加速/减速）。
  - 刷新策略优化：避开蛇头一定半径，或向空旷区域倾斜，提高可玩性。
  - 支持可控随机种子，便于复现实验与对比。

### 步骤5：死亡判定与结束/胜利

- 实现思路：
  - 失败条件：越界（坐标超边界）或自撞（蛇头出现在身体列表的其他位置）。
  - 胜利条件：达到设定分数即“达到目标”。
  - 结束流程是“状态机”转换：显示结果→选择重开或退出→若重开则重置状态。
- 文件与位置：
  - `snake.py`：`hit_wall()`（越界）、`hit_self()`（头部与身体重复）
  - `game.py.update()`：触发`show_gameover_dialog(win=False/True)`
- 具体操作：
  1) 故意撞墙或绕圈撞自己，观察是否弹出“Game Over”。
  2) 在`config.py`把`DEFAULT_WIN_SCORE`改为`3`，快速体验胜利流程。
  3) 在结束对话框中选择“Restart”，输入新的胜利分数再次开始。
- 你应看到：
  - 失败或胜利都会弹窗；可选择重新开始并修改胜利分数。
- 扩展：
  - 引入显式“状态机（State）”结构：Running/Win/GameOver，解耦更新与UI。
  - 增加关卡墙体/地图文件加载，形成不同地图与难度。
  - 设计“生命值/护盾”等替代失败条件，丰富玩法。

### 步骤6（选学）：分数显示与节奏

- 实现思路：
  - UI信息（模式/分数）是“状态的可视化反馈”，帮助玩家理解进行情况。
  - 节奏由“每秒帧数”控制，`tick`越高越快；也可把难度与分数挂钩（动态节奏）。
  - 分离“逻辑状态”和“显示文字”，培养“数据-视图分离”的意识。
- 文件与位置：
  - `game.py`：`draw_score()`渲染文字、`clock.tick(10)`帧率
- 具体操作：
  1) 修改`draw_score()`中的文本内容或位置（如在右上角显示）。
  2) 让速度随分数提升：把`clock.tick(10)`改成与`score`相关（如`10 + score // 2`）。
- 你应看到：
  - 分数与模式实时显示；分数越高游戏越快（若启用可变速度）。
- 扩展：
  - HUD 模块化：封装文本布局与皮肤，便于换肤与多语言。
  - 动态难度（DDA）：随分数/时间调整`tick`、特殊食物概率。
  - 加入音效与简单动画（吃到食物闪烁、得分提示）。

### 步骤7（选学）：简单 AI 思路

- 实现思路：
  - 把“找食物”转成一个“每帧决定方向”的问题：优先让蛇在x方向接近，再在y方向接近（或相反）。
  - 这是“贪心/最短曼哈顿距离”的朴素策略，简单直观但不考虑障碍，自然引出其局限。
  - 无论人还是AI，最终都只是在设定方向向量；接口统一、策略可替换。
- 文件与位置：
  - `snake_ai.py`：`SimpleSnakeAI.get_direction()`（基于`dx/dy`朝食物靠近）
  - `game.py`：`ai_decide_direction()`在 AI 模式生效
  - `snake_game.py`：启动时选择 AI 模式
- 具体操作：
  1) 运行`snake_game.py`，弹窗选择“Yes（AI 模式）”。
  2) 观察蛇会沿着 x 优先、再 y 方向靠近食物。
  3) 可选：把默认模式固定为`ai`（便于演示），或增加一个快捷键切换模式（进阶）。
- 你应看到：
  - 无需按键，蛇会自动朝食物移动，但可能撞墙/撞自己。
- 扩展：
  - 策略接口抽象：定义`BaseSnakeAI`，便于热插拔比较不同策略。
  - 人机协同：玩家按键优先，AI仅在空闲时给建议方向（辅助驾驶）。
  - 为AI增加“安全检查”中间层，过滤会立即撞墙/撞身的方向。

### 步骤8（拓展）：更安全的 AI（BFS）

- 实现思路：
  - 把网格看作图，蛇头是起点，食物是终点；用BFS按“步数最少”搜索路径。
  - 为避免自撞，把蛇身当作“暂时占用”的格子；但允许走到当前蛇尾（下一帧尾会移动腾位）。
  - 若无通路，退一步选择“不撞墙且不撞身”的方向作为保底策略（健壮性设计）。
- 文件与位置：
  - `snake_ai.py`：`SafeSnakeAI.get_direction()`（队列 BFS，访问集与边界判断，允许走到当前蛇尾）
  - `game.py`：保持 AI 模式，逻辑会调用更安全的路径选择
- 具体操作：
  1) 在 AI 模式下运行，观察蛇是否更少“自杀”。
  2) 结合注释讲解：为什么允许走到“当前蛇尾”？（下一帧尾部会移动，等价于空位）
  3) 可选挑战：为 BFS 增加“障碍格”（自行定义一组墙体坐标并在 BFS 和渲染中处理）。
- 你应看到：
  - 蛇更稳健地接近食物；当无路时选择一个尽量安全的方向。
- 扩展：
  - 用A*替代BFS（启发式更快）；可视化开放/关闭集合，展示搜索过程。
  - 多步“尾随”预测：模拟若干帧，综合考虑尾部移动后的可达性。
  - 无路时采用“空间最大化/沿墙走”等保命策略，结合启发式评分选择方向。

---

## 六、常见错误与排查

- 游戏窗口卡住/无响应：主循环内不要做过长的阻塞操作；保持每帧都`event→update→draw`。
- 方向键不生效：是否在玩家模式？检查`handle_events()`是否进入键盘分支。
- 食物刷在蛇身上：确保用`while True`随机直到不在`snake_body`中（`food.py`已处理）。
- 一吃就“穿越增长”或“无限变长”：检查`grow_flag`只在吃到时置`True`，下一帧自动复位。
- 文字/字体报错：`game.py`已做`SysFont`到`Font(None,24)`回退，仍异常可注释文字渲染临时绕过。

---

## 七、扩展

- 速度分级：随分数提高逐步加速（把`clock.tick()`的值与`score`关联）。
- 关卡墙体：新增“障碍格”，在`update()`中一并判碰撞。
- 皮肤主题：改颜色/格子大小/窗口尺寸，做“巨蛇模式”或“迷你模式”。
- 排行榜：把最高分存到本地文件`highscore.txt`。
- 可视化网格关闭：给网格线加开关，体验“无网格”难度。
